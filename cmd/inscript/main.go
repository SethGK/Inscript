package main

import (
	"fmt"
	"os"

	"github.com/SethGK/Inscript/internal/ast"          // Import ST package
	"github.com/SethGK/Inscript/internal/compiler"     // Import Compiler package
	"github.com/SethGK/Inscript/internal/vm"           // Import VM package
	parser "github.com/SethGK/Inscript/parser/grammar" // Import the ANTLR generated parser package
	"github.com/antlr4-go/antlr/v4"                    // Import ANTLR runtime
)

func main() {
	// 1. Read Source Code (Example: from a file specified as a command-line argument)
	if len(os.Args) < 2 {
		// Updated usage message with .ins extension
		fmt.Println("Usage: inscript <source_file.ins>")
		os.Exit(1)
	}
	filePath := os.Args[1]
	input, err := antlr.NewFileStream(filePath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading file %s: %v\n", filePath, err)
		os.Exit(1)
	}

	// 2. Lex and Parse
	lexer := parser.NewInscriptLexer(input)
	stream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)
	p := parser.NewInscriptParser(stream)

	// Add an error listener to capture syntax errors
	// The DiagnosticErrorListener will print errors to stderr automatically.
	// You might want to implement a custom error listener for more control.
	errorListener := antlr.NewDiagnosticErrorListener(true)
	p.AddErrorListener(errorListener)
	lexer.AddErrorListener(errorListener) // Also add to the lexer

	p.SetErrorHandler(antlr.NewDefaultErrorStrategy()) // Use default error recovery

	// Parse the program rule
	// The error listener will report errors during this call.
	parseTree := p.Program()

	// We don't have a direct way to get the *count* of errors from the default listener.
	// If the parsing process itself returned a non-nil result (parseTree) and didn't panic
	// due to unrecoverable errors, we can proceed. The DiagnosticErrorListener will
	// have already printed messages for any syntax errors found.
	// A more robust approach would involve a custom error listener that tracks errors.

	// For now, we'll proceed assuming the DiagnosticErrorListener has informed the user
	// if there were errors. If parsing failed critically, it might have panicked or
	// returned a nil parseTree (though the latter is less common with default error strategy).
	// A simple check for nil parseTree is not reliable for all error cases.
	// Relying on the listener printing errors and potentially exiting manually
	// or using a custom listener is the standard approach.

	// 3. Build AST
	builder := ast.NewASTBuilder() // Use your AST builder
	// Ensure the parseTree is not nil before attempting to build the AST,
	// although with default error strategy, it might not be nil even on errors.
	// The AST builder should ideally handle potential errors/incomplete nodes from the parse tree.
	astProgram := parseTree.Accept(builder).(*ast.Program)

	// Optional: Print a representation of the AST for debugging
	// fmt.Printf("AST: %+v\n", astProgram)

	// 4. Compile
	comp := compiler.New() // Create a new compiler instance
	bytecode, err := comp.Compile(astProgram)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Compilation error: %v\n", err)
		os.Exit(1)
	}

	// Optional: Print the generated bytecode for debugging
	fmt.Println("--- Bytecode ---")
	fmt.Println(bytecode.FormatInstructions())
	fmt.Println("--- Constants ---")
	fmt.Printf("%+v\n", bytecode.Constants)
	fmt.Println("----------------")

	// 5. Execute
	// Get the number of global variables from the compiler
	numGlobals := comp.NumGlobalVariables()
	vm := vm.New(bytecode, numGlobals) // Create a new VM instance

	// Run the bytecode
	result, err := vm.Run()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Runtime error: %v\n", err)
		os.Exit(1)
	}

	// Print the final result of the program if there was one
	// Note: For simple scripts, the result might be nil or the value of the last expression.
	fmt.Printf("Program finished. Result: %+v\n", result)

	fmt.Println("Execution finished.")
}
